trying to get a more efficient solution technique. My impression is that the Newton method is working, but it is not more efficient than the AL method. These are some of the things I have tried and some of the results I have got:

I now always multiply snGrad(c_mR) by mesh.magSf() because I think this is correct. (You were multiplying it by rMesh.magSf() which I think is wrong

I have tried using
Phi(n+1) = Phi(n) + phi
and solving for phi instead of Phi (phi instead of Psi)
Not sure why, I just wanted to try it. Doesn't make much difference

I have tried linear and upwind for the divergence term. Linear makes it run a bit quicker but not by much.

I have doubled the resolution in both directions which makes is ridiculously slow

I have found that it only works with a relaxation factor of 0.99.

I have changed the matchTolerance in system/blockMeshDict to 0.1 so that it is less fussy about the cyclic boundary conditions (I have gone back to using cyclics)

I have put the solver tolerance as 0 and the relative tolerance as 1e-6 so that it always solves the matrix, even if it has reached the tolerance.

I strange one - it is more convergent with gamma=-1 than with gamma=1.

In fact, gamma=-1 is more convergent than gamma=0 and gamma=0 is more convergent than gamma=1. A sign problem? (however this is case dependent)

Something else been bothering me when I look at the solutions of Phi. There is a discontinuity at the boundary because the monitor function is a discontinuity in the first derivative at the boundary. Could this be responsible for the convergence that is dependent on problem size?

And finally, thinking more about your laplacian formulation. I really like it because, in the formulation with advection, the solution is dependent on the level of Phi because one of the terms is Phi*laplacian(c_m). This is why we cannot fix a value. I tried different initial conditions for Phi and it made a small difference. However, we come back to the problem that in the linearisation of c/m, you are taking gradients of c_m wrt x, not wrt xi. So you would need to multiply some terms by (I+H)^-1 to make it correct.

I have done some playing around, created a code in directory Newton_HW and a case called Newton2D_HW and have pushed them to AtmosFOAM (I prefer to make new codes and new cases than branches so that there is less to recompile and I understand it better)
